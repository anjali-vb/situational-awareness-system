<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Situational Awareness System</title>
    
    <!-- ========================================
         CSS STYLES
    ======================================== -->
    <style>
        /* ----- RESET & BASE ----- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* ----- HEADER ----- */
        header {
            background: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
        }
        header h1 { font-size: 1.2em; font-weight: 500; }
        .status { display: flex; align-items: center; gap: 8px; font-size: 0.9em; }
        .status-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: #dc3545;
        }
        .status-dot.connected { background: #28a745; }

        /* ----- LAYOUT ----- */
        .main { display: flex; flex: 1; overflow: hidden; }
        .sidebar {
            width: 280px;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 15px;
        }
        .sidebar h2 {
            font-size: 0.85em;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        .center { flex: 1; display: flex; flex-direction: column; background: #f5f5f5; }

        /* ----- INFO BOX ----- */
        .info-box { background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 20px; }
        .info-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 0.9em; }
        .info-row:last-child { margin-bottom: 0; }
        .label { color: #666; }
        .value { font-family: monospace; color: #333; }

        /* ----- ALERTS ----- */
        .alert-list { max-height: 200px; overflow-y: auto; margin-bottom: 20px; }
        .alert { padding: 10px; border-radius: 6px; margin-bottom: 8px; border-left: 4px solid; }
        .alert.danger { background: #fff5f5; border-color: #dc3545; }
        .alert.warning { background: #fffbf0; border-color: #ffc107; }
        .alert.safe { background: #f5fff7; border-color: #28a745; }
        .alert-header { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .alert-target { font-weight: 600; }
        .alert-badge { font-size: 0.75em; padding: 2px 8px; border-radius: 3px; color: white; }
        .alert-badge.danger { background: #dc3545; }
        .alert-badge.warning { background: #ffc107; color: #333; }
        .alert-badge.safe { background: #28a745; }
        .alert-details { font-size: 0.85em; color: #666; }

        /* ----- TARGETS ----- */
        .target-list { margin-bottom: 20px; }
        .target {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 10px; background: #f8f9fa; border-radius: 4px;
            margin-bottom: 6px; font-size: 0.9em;
        }
        .target-id { font-weight: 600; color: #0066cc; }

        /* ----- LEGEND ----- */
        .legend { display: flex; flex-wrap: wrap; gap: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.85em; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        .legend-dot.own { background: #0066cc; }
        .legend-dot.safe { background: #28a745; }
        .legend-dot.warning { background: #ffc107; }
        .legend-dot.danger { background: #dc3545; }

        /* ----- RADAR ----- */
        .radar { flex: 1; position: relative; min-height: 400px; }
        #radarCanvas { position: absolute; top: 0; left: 0; cursor: grab; }
        #radarCanvas:active { cursor: grabbing; }
        .zoom-controls { position: absolute; bottom: 20px; left: 20px; display: flex; flex-direction: column; gap: 5px; }
        .zoom-controls button {
            width: 36px; height: 36px; border: none; background: white;
            border-radius: 6px; font-size: 1.3em; cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .zoom-controls button:hover { background: #f0f0f0; }
        .zoom-level { text-align: center; font-size: 0.8em; color: #666; }
        .compass { position: absolute; top: 20px; right: 20px; width: 60px; height: 60px; }
        .scale-bar {
            position: absolute; bottom: 20px; right: 20px; background: white;
            padding: 8px 12px; border-radius: 6px; font-size: 0.85em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* ----- CONTROLS ----- */
        .controls {
            background: white; padding: 12px 20px; display: flex;
            align-items: center; gap: 20px; flex-wrap: wrap; border-top: 1px solid #ddd;
        }
        .controls h3 { font-size: 0.8em; color: #666; text-transform: uppercase; }
        .btn-group { display: flex; gap: 8px; }
        .btn {
            padding: 8px 14px; border: 1px solid #ddd; border-radius: 6px;
            background: white; cursor: pointer; font-size: 0.9em; transition: background 0.2s;
        }
        .btn:hover { background: #f0f0f0; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: #0066cc; border-color: #0066cc; color: white; }
        .btn-primary:hover { background: #0055aa; }
        .btn-danger { background: #dc3545; border-color: #dc3545; color: white; }
        .btn-danger:hover { background: #c82333; }
        .btn-small { padding: 5px 10px; font-size: 0.8em; }
        .speed-control { display: flex; align-items: center; gap: 10px; }
        .speed-control input[type="range"] { width: 100px; }
        .step-control { display: flex; align-items: center; gap: 8px; }
        .step-input { width: 60px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; text-align: center; }
        .add-target { display: flex; align-items: center; gap: 8px; margin-left: auto; }
        .add-target input { width: 55px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em; }
        .add-target input[type="text"] { width: 50px; }
        .separator { width: 1px; height: 30px; background: #ddd; }

        /* ----- SCROLLBAR ----- */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f5f5f5; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }

        /* ----- RESPONSIVE ----- */
        @media (max-width: 900px) {
            .main { flex-direction: column; }
            .sidebar { width: 100%; max-height: 250px; border-right: none; border-bottom: 1px solid #ddd; }
            .controls { flex-direction: column; align-items: flex-start; gap: 10px; }
            .add-target { margin-left: 0; }
        }
    </style>
</head>

<body>
    <!-- HEADER -->
    <header>
        <h1>Situational Awareness System</h1>
        <div class="status">
            <span id="connectionText">Disconnected</span>
            <span class="status-dot" id="statusDot"></span>
        </div>
    </header>

    <!-- MAIN CONTENT -->
    <div class="main">
        <!-- SIDEBAR -->
        <div class="sidebar">
            <h2>Own Vessel</h2>
            <div class="info-box">
                <div class="info-row">
                    <span class="label">Position:</span>
                    <span class="value" id="ownPosition">(0.00, 0.00) nm</span>
                </div>
                <div class="info-row">
                    <span class="label">Speed:</span>
                    <span class="value" id="ownSpeed">0.0 kn</span>
                </div>
                <div class="info-row">
                    <span class="label">Heading:</span>
                    <span class="value" id="ownHeading">0.0°</span>
                </div>
            </div>

            <h2>⚠ Active Alerts</h2>
            <div class="alert-list" id="alertList">
                <p style="color: #999; text-align: center; padding: 20px;">No active alerts</p>
            </div>

            <h2>Target Vessels</h2>
            <div class="target-list" id="targetList">
                <p style="color: #999; text-align: center; padding: 10px;">No targets</p>
            </div>

            <h2>Legend</h2>
            <div class="legend">
                <div class="legend-item"><span class="legend-dot own"></span><span>Own</span></div>
                <div class="legend-item"><span class="legend-dot safe"></span><span>Safe</span></div>
                <div class="legend-item"><span class="legend-dot warning"></span><span>Warning</span></div>
                <div class="legend-item"><span class="legend-dot danger"></span><span>Danger</span></div>
            </div>
        </div>

        <!-- CENTER -->
        <div class="center">
            <div class="radar" id="radarContainer">
                <canvas id="radarCanvas"></canvas>
                <div class="zoom-controls">
                    <button id="zoomIn" title="Zoom In">+</button>
                    <div class="zoom-level" id="zoomLevel">1.0x</div>
                    <button id="zoomOut" title="Zoom Out">−</button>
                    <button id="resetView" title="Reset View" style="font-size: 1em;">⟲</button>
                </div>
                <svg class="compass" viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="45" fill="none" stroke="#ddd" stroke-width="2"/>
                    <text x="50" y="18" text-anchor="middle" fill="#0066cc" font-size="14" font-weight="bold">N</text>
                    <text x="88" y="54" text-anchor="middle" fill="#999" font-size="11">E</text>
                    <text x="50" y="92" text-anchor="middle" fill="#999" font-size="11">S</text>
                    <text x="12" y="54" text-anchor="middle" fill="#999" font-size="11">W</text>
                </svg>
                <div class="scale-bar"><span id="scaleValue">1 nm</span></div>
            </div>

            <div class="controls">
                <h3>Simulation</h3>
                <div class="btn-group">
                    <button id="btnStart" class="btn btn-primary">▶ Start</button>
                    <button id="btnPause" class="btn" disabled>⏸ Pause</button>
                    <button id="btnReset" class="btn btn-danger">↺ Reset</button>
                </div>
                <div class="step-control">
                    <button id="btnStep" class="btn">Step</button>
                    <input type="number" id="stepDt" class="step-input" value="0.1" min="0.01" max="1" step="0.01">
                    <span style="color: #888; font-size: 0.85em;">hrs</span>
                </div>
                <div class="speed-control">
                    <span style="color: #666;">Speed:</span>
                    <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
                    <span id="speedValue">1.0x</span>
                </div>
                <div class="separator"></div>
                <div class="add-target">
                    <span style="color: #0066cc; font-weight: 600;">Add Target:</span>
                    <input type="text" id="newTargetId" placeholder="ID">
                    <input type="number" id="newTargetX" placeholder="X" step="0.1">
                    <input type="number" id="newTargetY" placeholder="Y" step="0.1">
                    <input type="number" id="newTargetSpeed" placeholder="Spd" step="0.1">
                    <input type="number" id="newTargetHeading" placeholder="Hdg" step="1">
                    <button id="btnAddTarget" class="btn btn-primary">+ Add</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ========================================
         JAVASCRIPT - Object-Oriented Design
    ======================================== -->
    <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
        serverUrl: 'ws://localhost:8765',
        updateInterval: 100,
        defaultZoom: 50,
        minZoom: 10,
        maxZoom: 200
    };

    const COLORS = {
        own: '#0066cc',
        safe: '#28a745',
        warning: '#e6a000',
        danger: '#dc3545',
        grid: '#d0d0d0',
        gridMajor: '#b0b0b0',
        background: '#f5f5f5',
        text: '#666666'
    };


    // ============================================
    // CONNECTION CLASS
    // Manages WebSocket connection to server
    // ============================================
    class Connection {
        constructor(url, onMessage) {
            this.url = url;
            this.onMessage = onMessage;
            this.socket = null;
            this.isConnected = false;
            
            // DOM elements for status display
            this.statusDot = document.getElementById('statusDot');
            this.statusText = document.getElementById('connectionText');
        }

        connect() {
            this.socket = new WebSocket(this.url);

            this.socket.onopen = () => {
                this.isConnected = true;
                this.updateStatus();
                console.log('Connected to server');
                this.send({ command: 'step', dt: 0 });
            };

            this.socket.onclose = () => {
                this.isConnected = false;
                this.updateStatus();
                console.log('Disconnected - reconnecting...');
                setTimeout(() => this.connect(), 2000);
            };

            this.socket.onerror = (error) => {
                console.error('Connection error:', error);
            };

            this.socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.onMessage(data);
                } catch (e) {
                    console.error('Parse error:', e);
                }
            };
        }

        send(command) {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                this.socket.send(JSON.stringify(command));
            }
        }

        updateStatus() {
            this.statusDot.classList.toggle('connected', this.isConnected);
            this.statusText.textContent = this.isConnected ? 'Connected' : 'Disconnected';
        }
    }


    // ============================================
    // SIMULATION CLASS
    // Controls simulation state and timing
    // ============================================
    class Simulation {
        constructor(connection) {
            this.connection = connection;
            this.isRunning = false;
            this.speed = 1.0;
            this.timer = null;

            // DOM elements
            this.btnStart = document.getElementById('btnStart');
            this.btnPause = document.getElementById('btnPause');
            this.btnReset = document.getElementById('btnReset');
            this.btnStep = document.getElementById('btnStep');
            this.stepInput = document.getElementById('stepDt');
            this.speedSlider = document.getElementById('speedSlider');
            this.speedDisplay = document.getElementById('speedValue');

            this.bindEvents();
        }

        bindEvents() {
            this.btnStart.addEventListener('click', () => this.start());
            this.btnPause.addEventListener('click', () => this.pause());
            this.btnReset.addEventListener('click', () => this.reset());
            this.btnStep.addEventListener('click', () => this.step());
            this.speedSlider.addEventListener('input', (e) => this.setSpeed(parseFloat(e.target.value)));
        }

        start() {
            this.connection.send({ command: 'start' });
            this.isRunning = true;
            this.updateButtons();
            this.startTimer();
        }

        pause() {
            this.connection.send({ command: 'pause' });
            this.isRunning = false;
            this.updateButtons();
            this.stopTimer();
        }

        reset() {
            this.connection.send({ command: 'reset' });
            this.isRunning = false;
            this.updateButtons();
            this.stopTimer();
        }

        step() {
            const dt = parseFloat(this.stepInput.value) || 0.1;
            this.connection.send({ command: 'step', dt: dt });
        }

        setSpeed(speed) {
            this.speed = speed;
            this.connection.send({ command: 'speed', value: speed });
            this.speedDisplay.textContent = speed.toFixed(1) + 'x';
        }

        updateButtons() {
            this.btnStart.disabled = this.isRunning;
            this.btnPause.disabled = !this.isRunning;
        }

        startTimer() {
            if (this.timer) return;
            this.timer = setInterval(() => {
                if (this.isRunning && this.connection.isConnected) {
                    const dt = (CONFIG.updateInterval / 1000 / 3600) * this.speed;
                    this.connection.send({ command: 'step', dt: dt });
                }
            }, CONFIG.updateInterval);
        }

        stopTimer() {
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
        }
    }


    // ============================================
    // TARGET MANAGER CLASS
    // Handles adding and removing targets
    // ============================================
    class TargetManager {
        constructor(connection) {
            this.connection = connection;

            // Form elements
            this.inputId = document.getElementById('newTargetId');
            this.inputX = document.getElementById('newTargetX');
            this.inputY = document.getElementById('newTargetY');
            this.inputSpeed = document.getElementById('newTargetSpeed');
            this.inputHeading = document.getElementById('newTargetHeading');
            this.btnAdd = document.getElementById('btnAddTarget');

            this.bindEvents();
            this.setupEventListeners();
        }

        bindEvents() {
            this.btnAdd.addEventListener('click', () => this.add());
            
            // Enter key submits form
            const inputs = [this.inputId, this.inputX, this.inputY, this.inputSpeed, this.inputHeading];
            inputs.forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.add();
                });
            });
        }

        add() {
            const id = this.inputId.value.trim();
            const x = parseFloat(this.inputX.value);
            const y = parseFloat(this.inputY.value);
            const speed = parseFloat(this.inputSpeed.value);
            const heading = parseFloat(this.inputHeading.value);

            if (!id || isNaN(x) || isNaN(y) || isNaN(speed) || isNaN(heading)) {
                alert('Please fill in all fields with valid values');
                return;
            }

            this.connection.send({
                command: 'add_target',
                id, x, y, speed, heading
            });

            this.clearForm();
        }

        remove(targetId) {
            this.connection.send({ command: 'remove_target', id: targetId });
        }

        clearForm() {
            this.inputId.value = '';
            this.inputX.value = '';
            this.inputY.value = '';
            this.inputSpeed.value = '';
            this.inputHeading.value = '';
        }

        // ----------------------------------------
        // Event delegation for remove buttons
        // Called once to handle all dynamically created buttons
        // ----------------------------------------
        setupEventListeners() {
            document.addEventListener('click', (e) => {
                if (e.target.matches('.remove-target-btn')) {
                    const targetId = e.target.dataset.targetId;
                    this.remove(targetId);
                }
            });
        }
    }


    // ============================================
    // VIEWPORT CLASS
    // Handles zoom and pan for radar view
    // ============================================
    class Viewport {
        constructor(canvas, onUpdate) {
            this.canvas = canvas;
            this.onUpdate = onUpdate;
            
            this.zoom = CONFIG.defaultZoom;
            this.panX = 0;
            this.panY = 0;
            this.isDragging = false;
            this.dragStartX = 0;
            this.dragStartY = 0;

            // DOM elements
            this.zoomDisplay = document.getElementById('zoomLevel');
            this.scaleDisplay = document.getElementById('scaleValue');
            this.btnZoomIn = document.getElementById('zoomIn');
            this.btnZoomOut = document.getElementById('zoomOut');
            this.btnReset = document.getElementById('resetView');

            this.bindEvents();
        }

        bindEvents() {
            // Zoom buttons
            this.btnZoomIn.addEventListener('click', () => this.zoomBy(2));
            this.btnZoomOut.addEventListener('click', () => this.zoomBy(-2));
            this.btnReset.addEventListener('click', () => this.reset());

            // Mouse wheel zoom
            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                this.zoomBy(e.deltaY > 0 ? -1 : 1);
            });

            // Mouse drag to pan
            this.canvas.addEventListener('mousedown', (e) => {
                this.isDragging = true;
                this.dragStartX = e.clientX - this.panX;
                this.dragStartY = e.clientY - this.panY;
                this.canvas.style.cursor = 'grabbing';
            });

            this.canvas.addEventListener('mousemove', (e) => {
                if (!this.isDragging) return;
                this.panX = e.clientX - this.dragStartX;
                this.panY = e.clientY - this.dragStartY;
                this.onUpdate();
            });

            this.canvas.addEventListener('mouseup', () => this.stopDrag());
            this.canvas.addEventListener('mouseleave', () => this.stopDrag());
        }

        zoomBy(delta) {
            this.zoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, this.zoom * (1 + delta * 0.1)));
            this.updateDisplay();
            this.onUpdate();
        }

        reset() {
            this.zoom = CONFIG.defaultZoom;
            this.panX = 0;
            this.panY = 0;
            this.updateDisplay();
            this.onUpdate();
        }

        stopDrag() {
            this.isDragging = false;
            this.canvas.style.cursor = 'grab';
        }

        updateDisplay() {
            this.zoomDisplay.textContent = (this.zoom / CONFIG.defaultZoom).toFixed(1) + 'x';
        }

        updateScaleBar() {
            const distanceNm = 100 / this.zoom;
            let text;
            if (distanceNm >= 5) {
                text = `${Math.round(distanceNm / 5) * 5} nm`;
            } else if (distanceNm >= 1) {
                text = `${Math.round(distanceNm)} nm`;
            } else {
                text = `${distanceNm.toFixed(1)} nm`;
            }
            this.scaleDisplay.textContent = text;
        }
    }


    // ============================================
    // RADAR RENDERER CLASS
    // Draws the radar display on canvas
    // ============================================
    class RadarRenderer {
        constructor(canvas, viewport) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.viewport = viewport;
            this.container = document.getElementById('radarContainer');
            
            window.addEventListener('resize', () => this.resize());
            this.resize();
        }

        resize() {
            this.canvas.width = this.container.clientWidth;
            this.canvas.height = this.container.clientHeight;
        }

        render(world) {
            const width = this.canvas.width;
            const height = this.canvas.height;
            const zoom = this.viewport.zoom;
            const panX = this.viewport.panX;
            const panY = this.viewport.panY;

            // Calculate center (own vessel position)
            const ownOffsetX = world.own ? world.own.position.x * zoom : 0;
            const ownOffsetY = world.own ? world.own.position.y * zoom : 0;
            const centerX = width / 2 + panX - ownOffsetX;
            const centerY = height / 2 + panY + ownOffsetY;
            const viewCenterX = width / 2 + panX;
            const viewCenterY = height / 2 + panY;

            // Clear canvas
            this.ctx.fillStyle = COLORS.background;
            this.ctx.fillRect(0, 0, width, height);

            // Draw layers
            this.drawGrid(viewCenterX, viewCenterY, width, height);
            this.drawRangeRings(viewCenterX, viewCenterY);

            // Draw vessels
            if (world.targets) {
                world.targets.forEach(t => this.drawVessel(t, centerX, centerY, false));
            }
            if (world.own) {
                this.drawVessel(world.own, centerX, centerY, true);
            }

            this.viewport.updateScaleBar();
        }

        drawGrid(centerX, centerY, width, height) {
            const zoom = this.viewport.zoom;
            const ctx = this.ctx;

            // Minor grid (1 nm)
            ctx.strokeStyle = COLORS.grid;
            ctx.lineWidth = 0.5;
            this.drawGridLines(centerX, centerY, width, height, zoom);

            // Major grid (5 nm)
            ctx.strokeStyle = COLORS.gridMajor;
            ctx.lineWidth = 1;
            this.drawGridLines(centerX, centerY, width, height, zoom * 5);
        }

        drawGridLines(centerX, centerY, width, height, spacing) {
            const ctx = this.ctx;

            // Vertical lines
            for (let x = centerX % spacing; x < width; x += spacing) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = centerY % spacing; y < height; y += spacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        drawRangeRings(centerX, centerY) {
            const ctx = this.ctx;
            const zoom = this.viewport.zoom;

            ctx.strokeStyle = COLORS.gridMajor;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            [1, 2, 5, 10].forEach(range => {
                const radius = range * zoom;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = COLORS.text;
                ctx.font = '11px sans-serif';
                ctx.fillText(`${range} nm`, centerX + radius + 5, centerY);
            });

            ctx.setLineDash([]);
        }

        drawVessel(vessel, centerX, centerY, isOwn) {
            const ctx = this.ctx;
            const zoom = this.viewport.zoom;

            // Position
            const x = centerX + vessel.position.x * zoom;
            const y = centerY - vessel.position.y * zoom;

            // Color based on risk
            let color = COLORS.safe;
            if (isOwn) {
                color = COLORS.own;
            } else if (vessel.alert) {
                color = vessel.alert.risk === 'DANGER' ? COLORS.danger :
                        vessel.alert.risk === 'WARNING' ? COLORS.warning : COLORS.safe;
            }

            // Velocity vector
            const headingRad = vessel.heading_deg * Math.PI / 180;
            const vectorLen = vessel.speed_knots * zoom * 0.1;
            const vx = Math.sin(headingRad) * vectorLen;
            const vy = -Math.cos(headingRad) * vectorLen;

            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + vx, y + vy);
            ctx.stroke();

            // Vessel shape
            const size = isOwn ? 14 : 10;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(headingRad);

            // Triangle
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(-size * 0.6, size * 0.6);
            ctx.lineTo(size * 0.6, size * 0.6);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();

            // Label
            ctx.fillStyle = '#333';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(vessel.id, x, y + size + 14);

            // Alert info
            if (!isOwn && vessel.alert && vessel.alert.risk !== 'SAFE') {
                ctx.font = '9px sans-serif';
                ctx.fillStyle = color;
                ctx.fillText(vessel.alert.text || '', x, y + size + 26);
            }
        }
    }


    // ============================================
    // UI UPDATER CLASS
    // Updates sidebar displays
    // ============================================
    class UIUpdater {
        constructor() {
            this.ownPosition = document.getElementById('ownPosition');
            this.ownSpeed = document.getElementById('ownSpeed');
            this.ownHeading = document.getElementById('ownHeading');
            this.alertList = document.getElementById('alertList');
            this.targetList = document.getElementById('targetList');
        }

        update(world) {
            this.updateOwnVessel(world.own);
            this.updateAlerts(world.alerts);
            this.updateTargets(world.targets);
        }

        updateOwnVessel(own) {
            if (!own) return;
            this.ownPosition.textContent = `(${own.position.x.toFixed(2)}, ${own.position.y.toFixed(2)}) nm`;
            this.ownSpeed.textContent = `${own.speed_knots.toFixed(1)} kn`;
            this.ownHeading.textContent = `${own.heading_deg.toFixed(1)}°`;
        }

        updateAlerts(alerts) {
            if (!alerts || alerts.length === 0) {
                this.alertList.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">No active alerts</p>';
                return;
            }

            this.alertList.innerHTML = alerts.map(alert => {
                const risk = alert.risk.toLowerCase();
                const cpa = alert.cpa_nm !== null ? `CPA: ${alert.cpa_nm.toFixed(2)} nm` : 'No CPA';
                let tcpa = '';
                if (alert.tcpa_hours !== null) {
                    tcpa = alert.tcpa_hours >= 0 
                        ? `TCPA: ${(alert.tcpa_hours * 60).toFixed(1)} min` 
                        : 'Opening';
                }

                return `
                    <div class="alert ${risk}">
                        <div class="alert-header">
                            <span class="alert-target">Target ${alert.target_id}</span>
                            <span class="alert-badge ${risk}">${alert.risk}</span>
                        </div>
                        <div class="alert-details">${cpa}${tcpa ? ' • ' + tcpa : ''}</div>
                    </div>
                `;
            }).join('');
        }

        updateTargets(targets) {
            if (!targets || targets.length === 0) {
                this.targetList.innerHTML = '<p style="color: #999; text-align: center; padding: 10px;">No targets</p>';
                return;
            }

            this.targetList.innerHTML = targets.map(t => `
                <div class="target">
                    <div>
                        <span class="target-id">${t.id}</span>
                        <span style="color: #666; margin-left: 10px;">
                            (${t.position.x.toFixed(2)}, ${t.position.y.toFixed(2)}) nm
                        </span>
                        <span style="color: #888; margin-left: 8px; font-size: 0.85em;">
                            ${t.speed_knots.toFixed(1)} kn @ ${t.heading_deg.toFixed(0)}°
                        </span>
                    </div>
                    <button class="btn btn-danger btn-small remove-target-btn" data-target-id="${t.id}">✕</button>
                </div>
            `).join('');
        }
    }


    // ============================================
    // APPLICATION CLASS
    // Main app that ties everything together
    // ============================================
    class Application {
        constructor() {
            this.world = { own: null, targets: [], alerts: [] };

            // Initialize components
            this.connection = new Connection(CONFIG.serverUrl, (data) => this.onServerUpdate(data));
            this.simulation = new Simulation(this.connection);
            this.targetManager = new TargetManager(this.connection);
            
            const canvas = document.getElementById('radarCanvas');
            this.viewport = new Viewport(canvas, () => this.render());
            this.renderer = new RadarRenderer(canvas, this.viewport);
            this.ui = new UIUpdater();
        }

        start() {
            this.connection.connect();
        }

        onServerUpdate(data) {
            this.world = data;
            this.ui.update(this.world);
            this.render();
        }

        render() {
            this.renderer.render(this.world);
        }
    }


    // ============================================
    // START APPLICATION
    // ============================================
    const app = new Application();
    app.start();

    </script>
</body>
</html>
